Two Pointer 
---

üîπ Two-pointer algorithms are typically bucketed under Array / ArrayList problems, because:

- They require index-based access, which arrays and ArrayLists both support
- They rely on ordered elements (which Set, Map, and HashMap do not guarantee)
- They're often used for searching, partitioning, and optimization over arrays/lists



‚úÖ Common Use Cases for Two-Pointer Techniques
| Pattern / Problem Type                  | Description / Example                                            |
| --------------------------------------- | ---------------------------------------------------------------- |
| **Opposite ends** (`left` & `right`)    | Used in sorted arrays ‚Äî e.g., finding a pair that sums to target |
| **Fast/slow pointers** (a.k.a. Floyd‚Äôs) | Cycle detection in linked lists                                  |
| **Sliding window**                      | Maintain subarray/window of certain size or constraint           |
| **Duplicate removal**                   | In-place de-dupe of sorted array                                 |
| **Partitioning / Reversal**             | Reverse array, Dutch national flag, etc.                         |



‚úÖ Data Structures That Work with Two Pointers
| Structure      | Valid? | Why                        |
| -------------- | ------ | -------------------------- |
| `Array[]`      | ‚úÖ      | Indexable in O(1)          |
| `ArrayList<>`  | ‚úÖ      | Also indexable in O(1)     |
| `LinkedList<>` | ‚ùå      | No efficient random access |
| `Set`          | ‚ùå      | No order, no indexing      |
| `Map`          | ‚ùå      | Key-based, not indexable   |



üß† Common Two-Pointer Algo Questions
- Two Sum (sorted input)
- Container With Most Water
- Trapping Rain Water
- Remove Duplicates from Sorted Array
- Palindrome Check
- Sorted Squares
- Minimum Window Substring (hybrid: sliding window + map)