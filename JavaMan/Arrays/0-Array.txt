🧵 Java Native Arrays — Crash Course


🔹 1. What Are Native Arrays?

- Native arrays in Java are low-level, fixed-size containers for elements of the same type, including both:

Primitives: int[], char[], boolean[]
Reference types: String[], Object[], Integer[]

✅ Arrays are zero-indexed
✅ Arrays are mutable
❌ Arrays cannot grow or shrink after creation



🔹 2. Declaring & Initializing Arrays

| Syntax                       | What it Does                         |
| ---------------------------- | ------------------------------------ |
| `int[] arr = new int[5];`    | Declares an array of 5 ints (0-init) |
| `String[] names = {"a","b"}` | Inline initialization                |
| `int[] arr = new int[]{1,2}` | Explicit new with values             |



🔹 3. Common Array Operations (with Time Complexity)

| Operation                 | Example                           | Time Complexity | Notes                           |
| ------------------------- | --------------------------------- | --------------- | ------------------------------- |
| **Access by index**       | `arr[i]`                          | O(1)            | Fastest possible access         |
| **Update element**        | `arr[i] = 99;`                    | O(1)            | In-place update                 |
| **Loop over array**       | `for (int i = 0; i < arr.length)` | O(n)            | Use for processing              |
| **Enhanced for loop**     | `for (int x : arr)`               | O(n)            | Cleaner read-only               |
| **Get length**            | `arr.length`                      | O(1)            | Not a method — it’s a field     |
| **Clone**                 | `int[] b = arr.clone();`          | O(n)            | Deep copy (shallow for objects) |
| **Copy part of array**    | `Arrays.copyOf(arr, newLen)`      | O(n)            | Resizing behavior               |
| **Fill array with value** | `Arrays.fill(arr, 7);`            | O(n)            | Set all elements                |
| **Sort array**            | `Arrays.sort(arr)`                | O(n log n)      | Dual-pivot quicksort or Timsort |
| **Binary search**         | `Arrays.binarySearch(arr, key)`   | O(log n)        | Must be sorted first            |
| **To string**             | `Arrays.toString(arr)`            | O(n)            | For debugging                   |
| **Equality check**        | `Arrays.equals(a1, a2)`           | O(n)            | Element-wise compare            |

🔸 All operations are in java.util.Arrays



🔹 4. Array vs ArrayList — Key Differences

| Feature              | `int[]` / `T[]` (Native Array) | `ArrayList<T>`                        |
| -------------------- | ------------------------------ | ------------------------------------- |
| Size                 | Fixed                          | Dynamic                               |
| Stores primitives    | ✅ Yes                          | ❌ No (must use wrappers)              |
| Performance (access) | O(1)                           | O(1)                                  |
| Add/remove elements  | ❌ No                           | ✅ Yes                                 |
| Built-in methods     | ❌ Manual                       | ✅ Rich API                            |
| Used in interviews   | ✅ Common                       | ⚠️ Less common (allowed if clarified) |
| Used in backend work | ⚠️ Sometimes                   | ✅ Frequently used                     |



🔹 5. Array Patterns in Algorithms

| Pattern / Use Case          | How Arrays Are Used                 |
| --------------------------- | ----------------------------------- |
| **Two Pointer**             | Traverse with `i` and `j`           |
| **Sliding Window**          | Maintain `sum` or state over window |
| **Prefix Sum**              | Use `int[] prefix = new int[n+1]`   |
| **Frequency Count (a–z)**   | `int[] freq = new int[26];`         |
| **Reversing / Swapping**    | Use temp variable, in-place swap    |
| **Dynamic Programming**     | `dp[]`, `dp[][]` for state storage  |
| **Sorting/Subarray tricks** | Use `Arrays.sort()` then logic      |
| **Greedy / Jump Game**      | Track index/steps using `int[]`     |



🔹 6. Tips and Best Practices

✅ Use Arrays When:

- You know the size in advance
- You want raw performance
- You’re solving algorithm problems

⚠️ Be Careful:

- No bounds checks: arr[arr.length] throws ArrayIndexOutOfBoundsException
- .length is a field, not a method — no parentheses
- Arrays of objects (String[]) default to null



🔹 7. Utility Methods from java.util.Arrays

| Method                     | Description                   |
| -------------------------- | ----------------------------- |
| `Arrays.sort(arr)`         | Sorts in-place                |
| `Arrays.equals(a, b)`      | Element-by-element comparison |
| `Arrays.copyOf(arr, len)`  | Resize or shallow copy        |
| `Arrays.fill(arr, val)`    | Fill array with a constant    |
| `Arrays.binarySearch(...)` | Binary search (sorted only)   |
| `Arrays.toString(arr)`     | Human-readable array          |



🧪 Quick Examples

int[] arr = {3, 1, 4};
Arrays.sort(arr);                    // [1, 3, 4]
System.out.println(arr[0]);         // 1
System.out.println(arr.length);     // 3
int[] copy = Arrays.copyOf(arr, 5); // [1, 3, 4, 0, 0]



✅ Summary: Native Arrays Mastery Checklist

| Concept                            | ✅ |
| ---------------------------------- | - |
| Declare and initialize arrays      | ✅ |
| Loop and access elements           | ✅ |
| Understand fixed size nature       | ✅ |
| Use `Arrays` utility methods       | ✅ |
| Know when to prefer over ArrayList | ✅ |
| Apply to algorithm patterns        | ✅ |
| Understand time complexities       | ✅ |

